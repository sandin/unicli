# Unicli

UniCli 是一个 Unicorn Engine 的交互式命令行工具，它让你可以像使用 gdb或者lldb 一样使用 Unicorn 来进行快速的模拟执行，并重点让你能观察到整个执行的过程，甚至参与到这个过程。

这个项目的目标是提供一个易于使用的模拟执行的工具，而不是实现一个完整的模拟环境，有很多项目都尝试去实现这一点，大部分最后都发现这是一个几乎不可能完成的目标。它将让你能将注意力放在你需要模拟执行和分析的目标本身，而不是重复而枯燥的编码工作。

​                       

## 安装

使用pip安装:
```
$ pip install unicli
```

使用源码安装:
```
$ git clone git@github.com:sandin/unicli.git
$ cd unicli
$ pip install -r requirements.txt
```

> 注:  强烈推荐在 python venv 虚拟环境下使用 unicli。

​                 

## 帮助文档

* [Unicli使用说明](docs/commands_zh.md)，该文档中详细描述了每条命令的使用说明。

​            

## 示例演示

* [使用unicli破解字符串加密算法](samples/decrypt_string1_zh/README.md)，该文档中演示如何使用 Unicli 来破解一个二进制可执行文件中的字符串加密算法。

​               

## 快速开始

使用 pip 安装后，你可直接使用 `unicli` 命令来启动它：

```bash
$ unicli
UniCli 0.0.1
Type "help" for more information.
```

​            

或者你是通过代码安装的，直接用python运行它：

```
$ python -m unicli
```

​          

或者你想使用PyCharm运行它:

* 创建一个新的 Python [运行/调试 启动项], 按照找下来配置并运行它： 
  * Module name: `unicli`
  * Execution:
    * [x] Emulate terminal in output console (因为是命令行交互工具，必须勾选它)

​            

### 加载文件

unicli 支持直接加载 ELF/PE/Mach-O 文件到虚拟内存：

```bash
>>> load /your/path/libdemo.so
Map memory reserve address space [0x1000000 - 0x10fe000]
Map memory from file [0x0 - 0xe396c] to virtual memory [0x1000000 - 0x10e396c]
Map memory from file [0xe3000 - 0xe9110] to virtual memory [0x10f3000 - 0x10f9110]
Fill memory with zeros to align with page size [0x10f9110 - 0x10fa000]
Fill memory with zeros for .bss section [0x10fa000 - 0x10fd000]
Successfully loaded module: /your/path/libdemo.so
```
> 注: unicli 会根据加载的文件格式，模拟Linker自动加载该文件中各个Segments（ .text , .data, .rodata 等），并保证它们在内存中的地址偏移是和运行时一致的。

​            

### 模拟执行

unicli 支持多种执行方式：

* 区间模式，执行一个范围内的汇编指令：
```shell
>>> emu_start <start_addr> <end_addr>
```

* 步进模式，步进到下一条指令：
```shell
>>> emu_start <start_addr>
>>> step_inst
```
  * 步进模式，步进到下一个Block：
```shell
>>> emu_start <start_addr>
>>> step_block
```
  * 步进模式，步进到指定的地址：
```shell
>>> emu_start <start_addr>
>>> step_to <address>
```

​                 

在模拟执行的过程中，unicli 会打印所有执行的汇编代码，并且包括block的信息：

```
>>> emu_start 0x407E0 0x40844
Start emulation, range: 0x00000407e0 - 0x0000040844
0x00000407e0 blk_407e0:
0x00000407e0              add        x0, x20, #0x350
0x00000407e4              ldarb      w8, [x0]
0x00000407e8              tbz        w8, #0, #0x40a84
0x0000040a84 blk_40a84:
0x0000040a84              bl         #0x38550
0x0000038550 blk_38550:
0x0000038550              ret   
0x0000040a88 blk_40a88:
0x0000040a88              cbz        w0, #0x407ec
0x0000040a8c blk_40a8c:
0x0000040a8c              adrp       x8, #0xbd000
0x0000040a90              ldr        d0, [x8, #0x238]
0x0000040a94              adrp       x1, #0xfb000
0x0000040a98              adrp       x0, #0x43000
0x0000040a9c              adrp       x2, #0xf9000
0x0000040aa0              add        x1, x1, #0xab8
0x0000040aa4              mov        w8, #1
0x0000040aa8              mov        w9, #0x4385
0x0000040aac              add        x0, x0, #0x950
0x0000040ab0              add        x2, x2, #0
0x0000040ab4              strb       w8, [x1, #0xa]
0x0000040ab8              str        d0, [x1]
0x0000040abc              strh       w9, [x1, #8]
0x0000040ac0              bl         #0x37e10
0x0000040800 blk_40800:
 X8 => 0x00000000010fbab8    
0x0000040800              ldr        d0, [x8]
0x0000040804              ldrb       w10, [x8, #8]
0x0000040808              ldrb       w12, [x8, #9]
0x000004080c              ldr        d1, [x9, #0x230]
0x000004083c              mov        w2, #0x10
0x00000fbab8  30 78 34 38 34 37 31 36  38 00                    |0x4847168.      |
0x0000040840              mov        x1, xzr
Emulation done, range: 0x00000407e0 - 0x0000040844
```

​            

你还可以在模拟执行之前注册一些hook的子命令，当这个hook的事件触发的时候，这些子命令会被执行，并且随着打印的信息在合适的地址打印它，例如我们需要在运行到某个指定地址的时候一同打印当前某些寄存器或者内存的值：

```
>>> hook_block 0x40800 reg_read X8
hook block at 0x0000040800
   
>>> hook_code 0x4083c mem_read 0xFBAB8 0xa
hook code at 0x000004083c
```

那么在运行到这些地址的时候，就会打印这些值，让你阅读执行过程的日志时，能看到这些在当时的实时值：

```
0x0000040abc              strh       w9, [x1, #8]
0x0000040ac0              bl         #0x37e10
0x0000040800 blk_40800:
 X8 => 0x00000000010fbab8    
0x0000040800              ldr        d0, [x8]
0x0000040804              ldrb       w10, [x8, #8]
0x0000040808              ldrb       w12, [x8, #9]
0x000004080c              ldr        d1, [x9, #0x230]
0x000004083c              mov        w2, #0x10
```

里面说明了在运行 `40800` 这一行指令之前，`X8` 寄存器的值是 `0x00000000010fbab8`。

​          

### 读写内存

在执行的过程中，我们可以随时读写内存，例如我们不希望执行某些代码，则可以直接将其进行Patch：

```
>>> set ret "C0 03 5F D6"
>>> set nop "1F 20 03 D5"

>>> mem_write 0x38550 $ret  # .__cxa_guard_acquire
0x0000038550  C0 03 5F D6                                       |.._.            |
>>> mem_write 0x40528 $nop  # bl .__cxa_guard_release
0x0000040528  1F 20 03 D5                                       |. ..            |
```

这里我们将一个函数内的指令修改为了 `ret` 让它不做任何事情直接返回，将另一条执行直接修改为了 `nop` 不让它执行。

​              

然后我们可以在任何时候去读取内存，观察代码执行的结果：

```
>>> mem_read 0xFB560 0x19
0x00000fb560  43 68 65 63 6B 20 6F 76  65 72 6C 61 79 20 70 65  |Check overlay pe|
0x00000fb570  72 6D 69 73 73 69 6F 6E  00                       |rmission.       |

>>> mem_read 0xFBA88 0xa
0x00000fba88  30 78 34 34 34 39 44 34  34 00                    |0x4449D44.      |

>>> mem_read 0xFBAB8 0xa
0x00000fbab8  30 78 34 38 34 37 31 36  38 00                    |0x4847168.      |
```

​                 

当然如果我们需要查看大范围的内存，也可以将其dump到文件，然后使用你喜欢的任何一个二进制工具来分析它们：

```
>>> mem_read 0xFBAB8 0x100000 --out dump_memory_FBAB8.bin
0x00000fbab8 - 0x00001fbab8 1048576 bytes have been saved to the file: dump_memory_FBAB8.bin
```

​          

### 读取寄存器

除了内存以外，我们肯定还需要操作和观察寄存器，例如我们在准备执行一个函数之前，需要先为了映射一块内存作为栈内存使用，然后需要把所有的寄存器重置为0，并设置好 `sp` 寄存器，让它能使用我们准备好的栈内存：

```
>>> mem_map 0x00010000 8*1024*1024
0x0000010000 - 0x0000810000 rwx

>>> set sp 0x00010000+(8*1024*1024)
set sp = 0x00010000+(8*1024*1024)

>>> reg_write all 0 sp $sp
 X0 => 0x0000000000000000     X1 => 0x0000000000000000    
 X2 => 0x0000000000000000     X3 => 0x0000000000000000    
 X4 => 0x0000000000000000     X5 => 0x0000000000000000    
 X6 => 0x0000000000000000     X7 => 0x0000000000000000    
 X8 => 0x0000000000000000     X9 => 0x0000000000000000    
 X8 => 0x0000000000000000     X9 => 0x0000000000000000    
X10 => 0x0000000000000000    X11 => 0x0000000000000000    
X12 => 0x0000000000000000    X13 => 0x0000000000000000    
X14 => 0x0000000000000000    X15 => 0x0000000000000000    
X16 => 0x0000000000000000    X17 => 0x0000000000000000    
X18 => 0x0000000000000000    X19 => 0x0000000000000000    
X20 => 0x0000000000000000    X21 => 0x0000000000000000    
X22 => 0x0000000000000000    X23 => 0x0000000000000000    
X24 => 0x0000000000000000    X25 => 0x0000000000000000    
X26 => 0x0000000000000000    X27 => 0x0000000000000000    
X28 => 0x0000000000000000     FP => 0x0000000000000000    
 LR => 0x0000000000000000     SP => 0x0000000000000000    
 PC => 0x0000000000000000     SP => 0x000000000080ff00  
```

这里我们, 看到 `reg_write` 其实分成了两部分：

1. 首先 `reg_write all 0`, 表示将所有的寄存器值都初始化 `0` 。

2. 然后 `sp $sp`， 表示再将 `sp` 寄存器的值设置成我们刚才创建的本地变量的值，它指向了我们刚准备好的栈内存地址。

​             

在执行的过程中，我们需要随时观察某些寄存器的值：

```
>>> reg_read sp pc
 SP => 0x0000000000810000     PC => 0x0000000001040844  
```

​           

或者为了方便，我们直接查看所有的寄存器：

```bash
>>> reg_read all
 X0 => 0x00000000010fbab8     X1 => 0x0000000000000000    
 X2 => 0x0000000000000010     X3 => 0x0000000000000000    
 X4 => 0x0000000000000000     X5 => 0x0000000000000000    
 X6 => 0x0000000000000000     X7 => 0x0000000000000000    
 X8 => 0x00000000010fbab8     X9 => 0x0000000000000000    
 X8 => 0x00000000010fbab8     X9 => 0x0000000000000000    
X10 => 0x0000000000000038    X11 => 0x00000000000000bd    
X12 => 0x0000000000000043    X13 => 0x0000000000000000    
X14 => 0x0000000000000000    X15 => 0x0000000000000000    
X16 => 0x0000000000000000    X17 => 0x0000000000000000    
X18 => 0x0000000000000000    X19 => 0x0000000000000000    
X20 => 0x00000000000fbd50    X21 => 0x0000000000000000    
X22 => 0x0000000000000000    X23 => 0x0000000000000000    
X24 => 0x0000000000000000    X25 => 0x0000000000000000    
X26 => 0x0000000000000000    X27 => 0x0000000000000000    
X28 => 0x0000000000000000     FP => 0x0000000000000000    
 LR => 0x0000000001040acc     SP => 0x0000000000810000    
 PC => 0x0000000001040844  
```

​               

## 结语

在此，你基本已经了解了 Unicli 的基本使用方法，如需更多信息可以直接在 Unicli 命令行中输入 `help` 命令了解。

  

  

  


