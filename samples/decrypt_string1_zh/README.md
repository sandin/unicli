# 使用Unicli破解字符串加密算法

在这篇文章中，我们将展示如何使用 Unicli 来分析某个闭源软件的二进制可执行文件中的字符串加密算法。

这里我们要分析的样本是一个Android Arm64 ELF文件，该ELF文件中几乎所有字符串基本都是加密的，导致无法使用IDA Pro等反汇编工具直接查找字符串表来定位到一些关键的代码逻辑，因此分析它的第一件事情就是破解其字符串加密算法。

​                          

## init_array

这里我们重点要分析的是这个二进制中的加密字符串算法，因此首先会想到的就是去查看其 `.init_array` ，看其中是否存在解密字符串的一些逻辑代码，因为大部分的字符串加密算法都需要利用 `.init_array` 在加载阶段先解密部分字符串，或者为了做一些相关的初始化操作，因此我们先来看看这个二进制中的  `.init_array` ，如下：

```assembly
.init_array:00000000006BE840 ; ELF Initialization Function Table
.init_array:00000000006BE840 ; ===========================================================================
.init_array:00000000006BE840
.init_array:00000000006BE840 ; Segment type: Pure data
.init_array:00000000006BE840                 AREA .init_array, DATA, ALIGN=3
.init_array:00000000006BE848                 DCQ sub_137714
.init_array:00000000006BE850                 DCQ sub_18D2C0
.init_array:00000000006BE858                 DCQ sub_18DAC4
.init_array:00000000006BE860                 DCQ sub_190148
.init_array:00000000006BE868                 DCQ sub_1914D4
.init_array:00000000006BE870                 DCQ sub_193308
.init_array:00000000006BE878                 DCQ sub_194714
.init_array:00000000006BE880                 DCQ sub_1956D4
.init_array:00000000006BE888                 DCQ sub_195948
.init_array:00000000006BE890                 DCQ sub_1A148C
.init_array:00000000006BE898                 DCQ sub_1A3FE4
.init_array:00000000006BE8A0                 DCQ sub_1A732C
.init_array:00000000006BE8A8                 DCQ sub_565BF4
.init_array:00000000006BE8B0                 DCQ sub_5680FC
.init_array:00000000006BE8B8                 DCQ sub_65ECF8
.init_array:00000000006BE8C0                 DCQ sub_66F118
.init_array:00000000006BE8C8                 DCQ sub_6B8AD8
.init_array:00000000006BE8D7 ; .init_array   ends
```

从上面可以看到在 `.init_array` 中有很多函数，我们大致的先简单浏览一遍这些函数的反汇编代码，从中很轻易的就找到很多类似字符串解密的逻辑代码，例如在第2个函数 `sub_18D2C0` 中，该函数的反汇编代码如下：

```c++
void sub_18D2C0()
{
	v0 = 0LL;
  byte_6E70E0 ^= dword_6E70DC;
  byte_6E70E1 ^= dword_6E70DC;
  byte_6E70E2 ^= dword_6E70DC;
  byte_6E70E3 ^= dword_6E70DC;
  byte_6E70E4 ^= dword_6E70DC;
  byte_6E70E5 ^= dword_6E70DC;
  byte_6E70E6 ^= dword_6E70DC;
  byte_6E70E7 ^= dword_6E70DC;
  byte_6E70E8 ^= dword_6E70DC;
  byte_6E70E9 ^= dword_6E70DC;
  byte_6E70EA = 0;
  qword_6E9B90 = (__int64)&byte_6E70E0;
  do
  {
    v1 = (char *)&dword_6E70EC + v0++;
    v1[4] ^= dword_6E70EC;
  }
  while ( v0 != 32 );
  v2 = (unsigned int)&byte_4;
  a27bbg7bg7bg7bg[32] = 0;
 
  // ...
}
```

很明显，这段代码就是在做解密某块数据的逻辑，下面我们就演示如何使用 unicli 来模拟执行这一段代码，验证一下我们的猜想是否正确，并尝试分析出其字符串加密的具体算法。

​         

## 加载ELF

为了避免不必要的麻烦，这里我先将这个ELF进行了一些截取，去掉了大部分数据，只保留了其中部分我们本文需要的分析的 `.text` 段和 `.data` 段，我们会根据这些segment原来的偏移地址将它们使用 `load` 命令加载到 unicli 的虚拟内存空间来模拟执行和分析。

其实unicli的 `load` 命令是支持直接加载各种不同格式的文件，例如ELF/PE/Mach-O等格式，并且会模拟Linker来将将这些文件动态的加载到虚拟内存中，并且保证其各loadable segment的偏移都和运行时是保存一致的，这样我们模拟执行时就不会出现地址偏移上的问题。

当然除了这些封装格式以外，我们也可以选择直接加载一个原始内存块的二进制文件（RAW格式），这些内存可能是和我一样从某个ELF等文件中提取的部分内存片段，也可能是你从某个运行时的程序中dump出来的某些内存片段，我们只需要提供这些原始的内存块，以及它们在运行时的地址偏移，就可以将其按原样还原映射到 unicli 的虚拟内存中。

这里我是从ELF文件中提取了部分的内存片段，以及其对应的偏移如下：

```
.text 0x18D2C0 - 0x18D548
.data 0x6E70DC - 0x6E714D
```

我们根据这些信息，使用unicli的 `load` 命令将它们先映射到虚拟内存：

```
# load memory
load samples/decrypt_string1_zh/text_18D2C0.bin --format raw --arch arm64 --base 0x02000000 --offset 0x18D2C0
load samples/decrypt_string1_zh/data_6E70DC.bin --format raw --arch arm64 --base 0x02000000 --offset 0x6E70DC
```

​                       

## 反汇编

我们把代码段加载到虚拟内存以后，可以使用 `disasm` 或者 `men_read` 命令读取一些这些代码段的内存，验证一下我们映射的偏移是否正确：

```assembly
>>> disasm 0x18D2C0 0x18D2E0-0x18D2C0
0x000018d2c0              adrp       x10, #0x6e7000
0x000018d2c4              adrp       x9, #0x6e9000
0x000018d2c8              add        x10, x10, #0xdc
0x000018d2cc              mov        x8, xzr
0x000018d2d0              mov        x11, x10
0x000018d2d4              ldrb       w12, [x11, #4]!
0x000018d2d8              ldr        w13, [x10]
0x000018d2dc              eor        w12, w12, w13
0x000018d2e0              strb       w12, [x11]
```

这里我们可以看到，在读取内存的时候，我们可以直接使用基于模块加载基地址的相对地址，这个地址一般来说就是你在IDE pro里面看到的地址。这里假设你正在用另一个窗口使用IDA pro或者其他反汇编的工具打开了这个ELF文件，我们可以将这块内存的汇编对比一下来判断内存映射是否存在偏移的问题，验证我们的内存已经是否正确被映射好了。

​        

## 内存映射

一般情况下解密字符串的逻辑可能会将解密后的字符串保存到 `.bss` 段，因此我们习惯性的先使用 `men_map`命令来映射这些内存空间：

```
>>> mem_map 0x02000000+0x6E8550 0x6EF0F0-0x6E8550  # .bss segment
0x00026e8000 - 0x00026ef000 rwx
```

这里我们看到提供 `address` 和 `size` 参数时，我们可以使用一些简单的算术表达式（加减乘除）来方便我们输入，否则还需要另外找一个计算器来计算地址或偏移。

我们也可以使用 `mem_list` 来查看所有已经映射的内存区间：

```
>>> mem_list
0x000218d000 - 0x000218e000 rwx   // .text
0x00026e7000 - 0x00026e8000 rwx   // .data
0x00026e8000 - 0x00026ef000 rwx   // .bss
```

​            

## 栈内存

我们的目标是模拟执行 `sub_18D2C0` 这个函数中的部分汇编代码，因此在此之前，我们还需要初始化一段栈内存来给这个函数用，否则这个函数中关于栈的读取指令就无法正常工作了。

这里我们简单的再使用 `mem_map` 映射一段内存：

```
>>> mem_map 0x00010000 8*1024*1024
0x0000010000 - 0x0000810000 rwx
```

然后为了后续方便使用，我们将栈帧的值保存到了一个叫做 sp 的本地变量，后面我们就可以使用 `$sp` 来引用这个变量的值，这样更加方便。
```
>>> set sp 0x00010000+(8*1024*1024)-0x100
set sp = 0x00010000+(8*1024*1024)-0x100
```

​       

## 寄存器

在模拟执行之前，我们还需要使用 `reg_write` 命令来初始化一下所有的寄存器，并且把我们刚才创建的栈内存地址设置到 `sp` 寄存器中。

```
>>> reg_write all 0 sp $sp
 X0 => 0x0000000000000000     X1 => 0x0000000000000000    
 X2 => 0x0000000000000000     X3 => 0x0000000000000000    
 X4 => 0x0000000000000000     X5 => 0x0000000000000000    
 X6 => 0x0000000000000000     X7 => 0x0000000000000000    
 X8 => 0x0000000000000000     X9 => 0x0000000000000000    
 X8 => 0x0000000000000000     X9 => 0x0000000000000000    
X10 => 0x0000000000000000    X11 => 0x0000000000000000    
X12 => 0x0000000000000000    X13 => 0x0000000000000000    
X14 => 0x0000000000000000    X15 => 0x0000000000000000    
X16 => 0x0000000000000000    X17 => 0x0000000000000000    
X18 => 0x0000000000000000    X19 => 0x0000000000000000    
X20 => 0x0000000000000000    X21 => 0x0000000000000000    
X22 => 0x0000000000000000    X23 => 0x0000000000000000    
X24 => 0x0000000000000000    X25 => 0x0000000000000000    
X26 => 0x0000000000000000    X27 => 0x0000000000000000    
X28 => 0x0000000000000000     FP => 0x0000000000000000    
 LR => 0x0000000000000000     SP => 0x0000000000000000    
 PC => 0x0000000000000000     SP => 0x000000000080ff00  
```

这里我们, 看到 `reg_write` 其实分成了两部分：

1. 首先 `reg_write all 0`, 表示将所有的寄存器值都初始化 `0` 。

2. 然后 `sp $sp`， 表示再将 `sp` 寄存器的值设置成我们刚才创建的本地变量的值，它指向了我们刚准备好的栈内存地址。

    

## 模拟执行

在上下文都准备好的前提下，我们就可以开始模拟执行了，因为我们的目的并不是简单的获得解密以后的字符串，而是想分析它的字符串加密算法，因此我们将一个block一个block的执行这段汇编代码，除了这种步进的方式之外，也可以直接提供一个开始地址和结束地址，那么unicli会自动执行完这个范围内的所有汇编指令，然后你可以在它全部执行完毕后再查看内存获取解密后的字符串，但这里我们希望使用步进的方式来执行，因此只需要提供一个我们需要开始执行的指令的起始地址即可，如下：

```assembly
>>> emu_start 0x18D2C0
Start emulation, range: 0x000018d2c0 - 0x0000000000
0x000018d2c0 blk_18d2c0:
0x000018d2c0              adrp       x10, #0x6e7000
```

这里我们想步进分析的是这个ELF文件中 `.init_array`的的第2个函数 `sub_18D2C0`, 因此我们直接从这个函数的开始地址开始执行。

​              

在步进模式下，unicli 提供三种步进命令：

* `step_inst`, 步进到下一条指令，即一条指令一条指令的步进。
* `step_block`，步进到下一个block，即一个block一个block的步进。
* `step_to <address>`，步进到某个指定地址。

这里我们并不需要分析特别的指令，因此我们选择按block的细粒度来进行步进会比较快一些，即使用 `step_block` 的命令：

```assembly
>>> step_block
0x000018d2c4 blk_18d2c4:
0x000018d2c4              adrp       x9, #0x6e9000
0x000018d2c8              add        x10, x10, #0xdc
0x000018d2cc              mov        x8, xzr
0x000018d2d0              mov        x11, x10
0x000018d2d4              ldrb       w12, [x11, #4]!
0x000018d2d8              ldr        w13, [x10]
0x000018d2dc              eor        w12, w12, w13
0x000018d2e0              strb       w12, [x11]
0x000018d2e4              ldrb       w12, [x10, #5]
0x000018d2e8              ldr        w13, [x10]
0x000018d2ec              eor        w12, w12, w13
0x000018d2f0              strb       w12, [x10, #5]
0x000018d2f4              ldrb       w12, [x10, #6]
0x000018d2f8              ldr        w13, [x10]
0x000018d2fc              eor        w12, w12, w13
0x000018d300              strb       w12, [x10, #6]
0x000018d304              ldrb       w12, [x10, #7]
0x000018d308              ldr        w13, [x10]
0x000018d30c              eor        w12, w12, w13
0x000018d310              strb       w12, [x10, #7]
0x000018d314              ldrb       w12, [x10, #8]
0x000018d318              ldr        w13, [x10]
0x000018d31c              eor        w12, w12, w13
0x000018d320              strb       w12, [x10, #8]
0x000018d324              ldrb       w12, [x10, #9]
0x000018d328              ldr        w13, [x10]
0x000018d32c              eor        w12, w12, w13
0x000018d330              strb       w12, [x10, #9]
0x000018d334              ldrb       w12, [x10, #0xa]
0x000018d338              ldr        w13, [x10]
0x000018d33c              eor        w12, w12, w13
0x000018d340              strb       w12, [x10, #0xa]
0x000018d344              ldrb       w12, [x10, #0xb]
0x000018d348              ldr        w13, [x10]
0x000018d34c              eor        w12, w12, w13
0x000018d350              strb       w12, [x10, #0xb]
0x000018d354              ldrb       w12, [x10, #0xc]
0x000018d358              ldr        w13, [x10]
0x000018d35c              eor        w12, w12, w13
0x000018d360              strb       w12, [x10, #0xc]
0x000018d364              ldrb       w12, [x10, #0xd]
0x000018d368              ldr        w13, [x10]
0x000018d36c              eor        w12, w12, w13
0x000018d370              strb       w12, [x10, #0xd]
0x000018d374              strb       wzr, [x10, #0xe]
```

这个block的代码很长，里面做了大量了异或操作，我们有理由怀疑它就是一段加密或者解密的代码逻辑，接下来我们就来重点分析它。

​                

## Hook指令

在分析这段汇编的时候，我们发现因为它里面使用了几个寄存器不断来做加载内存，然后对其做异或运算，因此我们需要在模拟执行的过程中，将这些寄存器的值打印出来以便于我们理解它们，而不需要另外拿出一个计算器自己来算。

我们可以通过使用 `hook_code` 命令，在我们认为关键的地址打印出某些寄存器的值，例如：

```
>>> hook_code 0x18d2cc reg_read x10
>>> hook_code 0x18d2d4 reg_read x11
>>> hook_code 0x18d2dc reg_read w12 w13
>>> hook_code 0x18d2e0 reg_read w12
```

`hook_code` 命令支持在某个指定地址的指令执行之外先执行一条我们的子命令（如读取寄存器或内存），例如上面的例子，我们需要在某些地址观察某些寄存器的值，来帮忙我们快速理解代码逻辑，在添加这些 `hook` 之后，我们再重新执行一遍刚才那个block的汇编代码。

```assembly
>>> emu_start 0x18D2C0
Start emulation, range: 0x000018d2c0 - 0x0000000000
0x000018d2c0 blk_18d2c0:
0x000018d2c0              adrp       x10, #0x6e7000
>>> step_block
0x000018d2c4 blk_18d2c4:
0x000018d2c4              adrp       x9, #0x6e9000
0x000018d2c8              add        x10, x10, #0xdc
X10 => 0x00000000026e70dc    
0x000018d2cc              mov        x8, xzr
0x000018d2d0              mov        x11, x10
X11 => 0x00000000026e70dc    
0x000018d2d4              ldrb       w12, [x11, #4]!
0x000018d2d8              ldr        w13, [x10]
w12 => 0x0000000000000060     w13 => 0x000000000000004f    
0x000018d2dc              eor        w12, w12, w13
w12 => 0x000000000000002f    
0x000018d2e0              strb       w12, [x11]
```

现在我们可以看到，在代码执行的过程中，会随着汇编代码一同打印出这些重要寄存器的值，带着这些实时的上下文信息，我们可以很快的理解这段汇编代码的含义，下面我们就挑出重点的部分逐行来分析它们：

* 首先在 `18d2d4` 这一行，它读取了 `.data` 段 `0x26e70dc + 4` 地址内存的一个字节，将其存到了 `w12` 寄存器，通过 `hook` 我们可以观察到该寄存器（ `.data` 段 `0x26e70dc + 4` ）的值为 `0x60`。

* 然后紧接着在 `18d2d8` 这一行，它读取了 `.data` 段 `0x26e70dc` 地址内存的一个字节，将其存到了 `w13` 寄存器，该寄存器（ `.data` 段 `0x26e70dc` ）的值为 `0x4f`。

* 最后在 `18d2dc` 这一行，它把读取到的两个字节进行了异或运算，并将异或后的结果保存到了  `0x26e70dc + 4`  的地址，将上面的这一行汇编翻译成伪代码如下：

这里所有的操作其实都是基于 `.data` 段的 `0x26e70dc`地址后的几个字节，第0个字节看上去是一个用于异或加密/解密的key，而从第4个字节开始应该就是需要用异或来解密的密文，该汇编的逻辑用伪代码的理解如下：

```c++
w13 = load(0x26e70dc);       // 读取第0个字节：0x4f
w12 = load(0x26e70dc + 4);   // 读取第4个字节：0x60
tmp = w12 ^ w13              // 将这2个字节互相进行异或：0x4f ^ 0x60 = 0x2f
store(0x26e70dc + 4, tmp)    // 将异或后的结果(0x2f)写入到第4个字节的位置
```

​        

接下来我们看它是如何处理后面的字节：

```assembly
0x000018d2e4              ldrb       w12, [x10, #5]
0x000018d2e8              ldr        w13, [x10]
    => 0x000000000000003f        => 0x000000000000004f    
0x000018d2ec              eor        w12, w12, w13
    => 0x0000000000000070    
0x000018d2f0              strb       w12, [x10, #5]
```

我们可以看到第5个字节的处理方式和第4个字节的方式是一模一样，也是将其和第0个字节进行异或计算，然后把异或后的值保存到第5个字节的当前位置。

继续往下面看我们可以观察到，我们也可以发现它对 `0x26e70dc`地址后的 `0xd` 个字节都进行了同样的逻辑运算。

最后我们来看最后一行的汇编，如下：

```
0x000018d374              strb       wzr, [x10, #0xe]
```

在最后一行它将 `0x26e70dc` 后第`0xe` 的字节重置为了 `0`,  这里我们可以很轻易的猜测出这个地址就是该字符串的最后一个字节，即字符串末尾的 `0`。

​                       

## 读取内存

因为这些代码都是在读写操作 `.data`段的地址为 `0x26e70dc` ，长度为 `0xe` 的内存块，因此我们首先来观察这一块内存在模拟执行之前的原始数据是怎样的，这里我们使用 `mem_read` 命令先读取这段内存的值来看看：

```
>>> mem_read 0x06e70dc 0xe
               0  1  2  3  4  5  6  7   8  9  a  b  c  d  e
0x00006e70dc  4F 00 00 00 60 3F 3D 20  2C 60 3C 3B 2E 3B 00     |O...`?= ,`<;.;. |
```

然后在这段汇编模拟执行完以后，我们再来观察这一段内存里面的值：

```
>>> hook_code 0x18d378 mem_read 0x06e70dc 0xf
0x000018d374              strb       wzr, [x10, #0xe]
               0  1  2  3  4  5  6  7   8  9  a  b  c  d  e
0x00006e70dc  4F 00 00 00 2F 70 72 6F  63 2F 73 74 61 74 00     |O.../proc/stat. |
```

在这里我们已经可以分别看到了该加密字符串的密文和明文了。

​               

## 加密算法

到此我们已经完整的分析了这个二进制可执行文件中的第一个字符串的解密过程，我们通过观察模拟执行过程中寄存器的值和执行前后内存的对比，可以很容易的分析并理解这段汇编代码的逻辑，该字符串加密的算法还是比较简单的，我们以上面这个字符串为例，总结一下其具体的字符串加密和解密的算法。

​                

首先它在ELF文件的  `.data` 段预先放置了一段加密的数据，地址为 `0x26e70dc`，长度为 `0xf`。其中前面4个字节是用于解密的秘钥，而后面的字节是加密后的字符串的密文，如下：

秘钥： `4F 00 00 00`

密文：`60 3F 3D 20 2C 60 3C 3B 2E 3B 00`

算法：用秘钥的第1个字节和密文的每个字节进行异或运算，即可得到解密后的字符串明文。

明文：`2F 70 72 6F 63 2F 73 74 61 74 00`

解密的字符为：`/proc/stat`

​            

到此你基本已经掌握了 Unicli 命令行工具的主要使用方法，关于更多的信息你可以直接在 Unicli 命令行中输入 `help` 命令来了解。
